* ASP.NET Core controllers use Routing middleware to match the URLs of incoming requests and map them to actions. Route templates are: 	-defined in startup code or attributes, 	-describe how URL paths are matched to actions, and 	-are used to generate URLs for links. Actions are either conventionally routed or attribute routed. 
* Controllers
    * A Controller is a class used to define and group a set of Action methods. Controllers logically group similar Actions together. This allows routing, caching, and authorization to be applied collectively. 
    * Within the Model-View-Controller pattern, a Controller is responsible for the initial processing of a request and instantiation of a Model. Business decisions should be performed within the Model layer.
    * To be classified as a Controller, at least one of these conditions is true: The class name is suffixed with Controller. The class inherits from a class whose name is suffixed with Controller. The [Controller] attribute is applied to the class. 
    * Controller classes reside in the project's root-level Controllers directory and inherit from Microsoft.AspNetCore.Mvc.Controller (the Controller class).
* Action Methods
    * An Action method is a method in a Controller that handles requests.  All public methods in a Controller (except those with the [NonAction] attribute) are Actions.  Parameters on Actions are bound to request data and are validated using ModelBinding.  Model validation occurs for everything that’s Model-Bound.  The ModelState.IsValid method indicates whether ModelBinding and validation succeeded. Action methods should contain logic for mapping a request to a business concern.  Business concerns should typically be represented as services that the Controller accesses through Dependency Injection. Actions can return anything, but usually return an IActionResult or Task<IActionResult> (for async methods).
* Model Binding
    * Controllers and Action methods work with data that comes from HTTP requests. (Ex. POSTed form fields provide values for the properties of the model.)  Writing code to retrieve each of these values and convert them from strings to .NET types would be tedious and error-prone. ModelBinding automates this process. 
    * The ModelBinding system: Retrieves data from various sources such as route data, form fields, and query strings. Provides the data to Controllers in Action method parameters and public Properties. Converts string data to .NET types. Updates Properties of complex types.
    * In this example, ModelBinding goes through the following steps for the request at the bottom. The routing system selects the correct action method. It needs the first parameter of GetByID (id) and looks through the HTTP request. It finds id = "2" in the route data. The system converts string "2" into integer 2. It finds the next parameter of GetByID(dogsOnly). The system finds "DogsOnly=true" in the query string. Name matching is not case-sensitive. The system converts the string "true" to a boolean true.
* Conventional Routing
    * Startup.Configure() typically has code similar to the following when using conventional routing.  Inside the call to UseEndpoints(), .MapControllerRoute() is used to create a route. This single route is named “default”. /Home/Index/<args> be the default route used when a request arrives to the base URL.
    * The route template (in Startup.cs) "{controller=Home}/{action=Index}/{id?}“ matches a URL path like /Products/Details/5. The route template tokenizes(extracts) the route values: Controller = Products,  Action = Details,  id = 5 This results in a match if the app has a Controller named ProductsController and an Action called Details. The id value is optional due to the ?.
* Attribute Routing – REST API’s
    * RESTful APIs should use Attribute Routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs. Attribute Routing uses sets of Attributes on each Controller Action to map Actions directly to route templates. The following StartUp.Configure() code is typical for a RESTful API. .MapControllers() is called inside UseEndpoints() to map attribute routed controllers.
    * HomeController matches a set of URLs similar to what the default conventional route {controller=Home}/{action=Index}/{id?} matches. Conventional Routing handles routes more succinctly, but Attribute Routing allows (and requires) precise control over which route templates apply to each Action.  With Attribute Routing, the Controller name and Action names no longer play a role in which Action is matched.
* Attribute Routing - HTTP Verb Templates
    * ASP.NET Core has these HTTP verb templates: [HttpGet], [HttpPost], [HttpPut], [HttpDelete], [HttpHead], [HttpPatch].  The GetProduct() Action method includes the "{id}" template, therefore ‘id’ is appended to the "api/[controller]" template above the Controller, so GetProduct() template is "api/test2/{id}".  Therefore, GetProduct(string id) can match GET requests of the form:  /api/test2/123 or /api/test2/{any string}.
